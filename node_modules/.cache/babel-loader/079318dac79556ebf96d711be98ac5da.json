{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n  constructor(gpgpu) {\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n  acquireTexture(shapeRC, usage, isPacked) {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n    let newTexture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n    return newTexture;\n  }\n  releaseTexture(texture, shape, logicalTexType, isPacked) {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n  log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n  }\n  get numBytesAllocated() {\n    return this._numBytesAllocated;\n  }\n  get numBytesFree() {\n    return this._numBytesFree;\n  }\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  const glany = gl;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  let numElements;\n  if (isPacked) {\n    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n  } else {\n    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}","map":{"version":3,"mappings":"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","names":["env","getInternalFormatForFloat16MatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","getInternalFormatForFloat32MatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getPackedMatrixTextureShapeWidthHeight","getUnpackedMatrixTextureShapeWidthHeight","PhysicalTextureType","TextureUsage","TextureManager","constructor","gpgpu","acquireTexture","shapeRC","usage","isPacked","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","freeTextures","usedTextures","texBytes","computeBytes","gl","textureConfig","length","numFreeTextures","numUsedTextures","_numBytesFree","log","newTexture","shift","push","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","_numBytesAllocated","releaseTexture","texture","shape","logicalTexType","deleteTexThreshold","get","deleteMatrixTexture","texList","texIndex","indexOf","Error","splice","logEnabled","total","console","freeRatio","Math","round","numBytesAllocated","numBytesFree","getNumUsedTextures","getNumFreeTextures","dispose","texShape","forEach","tex","numBytesForInternalFormat","internalFormat","glany","R32F","R16F","RGBA32F","RGBA","RGBA16F","RGBA8","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","width","height","bytesPerElement","getPhysicalTextureForRendering","getBool","UPLOAD","RENDER","DOWNLOAD","PIXELS","shapeRowsCol"],"sources":["C:\\Users\\vivek\\OneDrive\\Desktop\\College\\z#5_Internships\\IISC\\tfjs-backend-webgl\\src\\texture_manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, Texture, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  private _numBytesFree = 0;  // How many bytes that have been allocated\n                              // are available for reuse.\n  private freeTextures: {[shape: string]: Texture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: Texture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): Texture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: Texture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: Texture, shape: [number, number], logicalTexType: TextureUsage,\n      isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n"]},"metadata":{},"sourceType":"module"}